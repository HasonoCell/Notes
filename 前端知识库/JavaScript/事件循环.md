# 一步步理解事件循环的诞生原因以及执行机制
## 进程和线程？
进程：程序运行需要有它专属的内存空间，可以简单将这个内存空间理解为进程。  
**每个应用至少拥有一个进程，进程之间相互独立，经过双方同意后可互相通信。**

线程：线程用来运行程序的代码，**一个进程至少拥有一个线程去执行它**，所以在进程开启后会自动开启一个线程，即**主线程**。如果程序需要执行多块代码，就需要多个线程。

## 浏览器有哪些进程和线程？
浏览器是一个多进程多线程的应用程序，为了避免互相影响，在启动浏览器后，会自动启动多个进程。

_你可以在浏览器的任务管理器中查看你当前的所有进程。_

其中，最主要的进程有：

1. 浏览器进程：主要负责界面显示，用户交互，子进程管理等。浏览器进程内部会启动多个线程执行不同的任务。
2. 网络进程：主要负责加载网络资源，网络进程内部会启动多个不同的线程执行不同网络任务。
3. **渲染进程(重要)**：渲染进程启动后，会启动一个渲染主线程，主线程将会执行 HTML，CSS，JS 代码。默认情况下，浏览器会为每个标签页开启一个新的渲染进程，以保证不同标签页之间互不影响。_(该默认模式未来可能会改变，可以查看 Chrome 官方文档)_

## 渲染主线程是如何工作的？
渲染主线程是浏览器中最繁忙的线程，它的任务包括但不限于：**解析 HTML，解析 CSS，计算样式和布局，处理图层，每秒渲染页面60次(60帧)，执行全局 JS 代码，执行事件处理函数，执行计时器回调函数......**

**具体查看**[**浏览器渲染原理**](https://www.yuque.com/hasonocell/ggddbr/uzfmra7vkynv6p50)

要执行如此多的任务，主线程遇到了一个前所未有的难题：如何调度任务？比如：

1. 我正在执行一个 JS 函数，执行到一半时用户点击了按钮，我应该去立即执行该事件的回调函数吗？
2. 我正在执行一个 JS 函数，执行到一半时某个计时器计时结束，我应该去立即执行该计时器的回调函数吗？
3. 浏览器进程通知我“用户点击了按钮”，与此同时某个计时器结束计时，我该去执行哪一个呢？

**渲染主线程采用了队列的办法来解决任务调度**：

1. 一开始，渲染主线程进入一个无限循环，
2. 每一次循环会检查任务队列是否存在任务。如果有，取第一个任务出来执行，执行完后进入下一次循环；如果没有，进入等待状态。
3. 渲染进程中的其它线程，以及其他进程的线程可以随时向任务队列添加任务，新任务会放在任务队列的末尾。渲染主线程若在等待，将会被唤醒以继续循环执行任务。

**整个过程被称为事件循环。**

## 若干解释
### 何为异步？
代码在执行过程中，会遇到一些无法立即处理的任务，比如：

1. 计时完成后需要执行的任务：**setTimeout，setInterval**
2. 网络通信后需要执行的任务：**XHR，Fetch**
3. 用户触发事件后需要执行的任务：**addEventListener**

如果让渲染主线程一直等待这些任务达到其执行的时机，就会长期阻塞主线程，从而导致浏览器“卡死”。渲染主线程执行着极其重要的页面渲染工作，所以绝对不能发生阻塞。浏览器采用了**异步**的方法来解决问题。

_JS 同步执行_

![](https://cdn.nlark.com/yuque/0/2025/jpeg/53866714/1752138710493-0c9c5785-0bed-4931-adec-b7796a5f50e8.jpeg)

_JS 异步执行_

![](https://cdn.nlark.com/yuque/0/2025/jpeg/53866714/1752138722515-9819be15-aac4-4b41-89b3-9e7fd1c50da6.jpeg)

**如何理解 JS 的异步（重点）**：**JS 是一门单线程的语言，这是因为它运行在渲染主线程中，由渲染主线程来执行 JS 代码（HTML 中的 script 标签），而渲染主线程只有一个。由于渲染主线程承担着多个任务，如渲染页面，执行 JS，如果采用同步的方式，就有可能导致渲染主线程发生阻塞，导致任务队列里的其它任务无法执行，不仅会导致繁忙的主线程白白消耗时间等待，也会造成浏览器页面的卡死。**

**所以浏览器采用异步的方式，具体做法是：当某些无法立即处理的任务发生时(如计时器，网络，事件监听)，渲染主线程会将这些任务交给其它线程处理，而自己去执行后续的任务。当其它线程执行完毕(如计时完毕，监听到事件)，会将传入的回调函数包装成任务加入任务队列末尾，等待主线程调度执行。主线程永不发生阻塞，保证了页面的流畅渲染。**

### JS 为何会阻碍渲染
先看代码：

```html
<h1>Hello!</h1>
<button>Change</button>
<script>
  const h1 = document.querySelector('h1')
  const button = document.querySelector('button')

  // 死循环指定的时间
  function delay(duration) {
    const start = Date.now()
    while (Date.now - start < duration) {}
  }

  button.addEventListener('click', () => {
    h1.textContent = 'Goodbye!'
    delay(3000)
    // h1 的内容在 3 秒后才会被更新
    // 这段代码会阻塞主线程，导致页面无法响应
  })
</script>

```

点击按钮后，代码是这样执行的：

1. 渲染主线程先执行前两行代码，得到 h1，button 两个元素
2. 继续执行，发现 **addEventListener**，交给**交互线程**监听用户点击，此时主线程所有任务执行完，进入等待状态
3. 当**交互线程**监听到用户点击，将回调函数**包装成任务对象**加入**任务队列**
4. 主线程检查到任务队列中存在任务，开始执行，执行回调函数过程中，h1 的 textContent 被更改（**注意，这里只是值发生了更改，并未重新渲染到页面**），这一更改产生了一个新的**重新绘制**任务加入到任务队列；主线程继续执行 delay 函数，**一直死循环 3 秒**之后，回调函数执行完毕
5. 主线程从任务队列中取出**重新绘制**任务并执行，页面在延迟 3 秒后更改

### 任务有优先级吗
**任务没有优先级，在任务队列中先进先出，但是任务队列之间存在优先级差异**。

根据 W3C 的最新解释：

+ 每个任务都有一个任务类型，同一个任务类型的任务必须在同一个队列，不同类型的任务可以分属于不同的队列。
+ 浏览器必须准备好一个微队列，**微队列中的任务优先所有其他任务执行。**

_随之浏览器复杂度的急剧提升，W3C 不再使用宏任务队列的说法，而是将__**宏任务**__队列细分为了延时队列，交互队列等等队列。_

在目前 Chrome 的实现中，至少包含了下面的队列：

+ **延时队列**：用于存放计时器到达后的回调任务，**优先级中**
+ **交互队列**：用于存放用户操作后产生的事件处理任务，**优先级高**
+ **微队列**：用户存放需要最快执行的任务，**优先度最高。添加任务到微队列的主要方式是使用 Promise，MutationObserver**

**<font style="color:#DF2A3F;">注意：每执行完一个宏任务，都会检查微任务队列并且执行微任务。</font>**

```javascript
function func() {
  console.log(1)
  Promise.resolve().then(function () {
    console.log(2)
  })
}

setTimeout(function () {
  console.log(3)
  Promise.resolve().then(func)
}, 0)

Promise.resolve().then(function () {
  console.log(4)
})

console.log(5)

// 输出结果为 5 4 3 1 2
```

**阐述一下 JS 的事件循环机制（重点）：事件循环又称消息循环，是浏览器渲染主线程的工作方式。在 Chrome 的 C++ 源码中，它开启一个不会结束的 for 循环，每次循环从消息队列中取出第一个任务执行，而其它线程只需要在合适的时机将任务加入到队列末尾即可。**

**过去把任务队列简单分为宏任务和微任务，这种说法目前已经无法满足复杂的浏览器环境，取而代之的是一种更加灵活多变的处理方式，将宏任务队列细分为了多种类型的队列。**

**根据 W3C 官方的解释，每个任务都有不同的类型，同类型任务必须在同一个队列，不同的任务可以属于不同的队列。不同任务队列有不同的优先级。在一次事件循环中，由浏览器自行决定取哪一个队列的任务。但浏览器必须有一个微队列，它具有最高的优先级，必须优先调度执行。**

**总结：单线程是异步产生的原因，事件循环是异步的实现方式。**

