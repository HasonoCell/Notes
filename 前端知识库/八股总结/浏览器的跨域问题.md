### 第一部分：什么是跨域问题？
#### 1. 核心概念：同源策略
跨域问题的根源是浏览器的**同源策略**。这是一种重要的安全机制，它限制了从一个源加载的文档或脚本如何与另一个源的资源进行交互。

什么是“同源”
如果两个 URL 的协议、域名、端口三者完全相同，则它们属于同源。

| 当前页面URL                                  | 请求目标URL                                 | 是否同源  | 原因                       |
| :--------------------------------------- | :-------------------------------------- | :---- | :----------------------- |
| `https://www.example.com/index.html`     | `https://www.example.com/api/user`      | **是** | 协议、域名、端口均相同              |
| `https://www.example.com/index.html`     | `http://www.example.com/api/user`       | **否** | **协议**不同 (HTTPS vs HTTP) |
| `https://www.example.com:443/index.html` | `https://www.example.com:8080/api/user` | **否** | **端口**不同 (443 vs 8080)   |
| `https://www.example.com/index.html`     | `https://api.example.com/user`          | **否** | **域名**不同 (www vs api)    |
| `https://www.example.com/index.html`     | `https://google.com/api/user`           | **否** | **域名**完全不同               |


**同源策略的限制行为：**

+ **AJAX请求 (XMLHttpRequest / Fetch API)**：默认不能跨域发送请求。
+ **DOM操作**：无法通过JS访问跨域iframe内的DOM（例如，父页面无法读取不同源iframe里的内容）。
+ **Cookie、LocalStorage、IndexedDB**：无法读取跨域站点的存储数据。



#### 2. 为什么需要同源策略？
没有同源策略将是极其危险的。假设你登录了银行网站`bank.com`，并保留了Cookie。然后你不小心访问了一个恶意网站。如果没有同源策略，这个恶意网站上的JS就可以向`bank.com`发起AJAX请求，浏览器会自动带上你的Cookie，恶意网站就能冒充你的身份获取你的银行数据、进行转账等操作。这就是**CSRF（跨站请求伪造）**攻击的原理之一。同源策略有效地防止了这类行为。

#### 3. 什么是跨域问题？
当前端应用（运行在`https://www.my-site.com`）的JS代码尝试使用`fetch`或`XMLHttpRequest`向不同源的API（例如`https://api.other-site.com`）发起请求时，浏览器会基于同源策略**拦截**这个响应，即使服务器成功响应了（状态码可能是200），浏览器也不会将响应结果交给前端JS代码，并在控制台报一个类似以下的错误：

_Access to fetch at _`_‘https://api.other-site.com/data’_`_ from origin _`_‘https://www.my-site.com’_`_ has been blocked by CORS policy: No ‘Access-Control-Allow-Origin’ header is present on the requested resource._

**关键点**：跨域请求的限制是**浏览器**的行为，不是服务器拒绝请求。服务器很可能已经接收并处理了请求，但浏览器“卡”住了响应。

---

### 第二部分：解决跨域问题的常见方法
解决跨域问题的核心思想是“绕开”或“让浏览器批准”同源策略的限制。

#### 方法一：CORS（跨域资源共享）
这是最主流、最正规的跨域解决方案，**需要后端配合**。

**原理**：CORS是一种W3C标准。它通过**添加额外的HTTP头部**来告诉浏览器，允许运行在一个Origin上的Web应用访问位于不同Origin上的指定资源。

**工作流程（简单请求 / 非简单请求）**：

1. **简单请求**：
    - **条件**：请求方法是`GET、HEAD、POST`之一，且`Content-Type`仅限于`text/plain`、`multipart/form-data`、`application/x-www-form-urlencoded`。
    - **过程**：浏览器直接发出请求，并在请求头中自动添加`Origin`字段（如 `Origin: https://www.my-site.com`）。服务器收到后，如果同意请求，就在响应头中包含`Access-Control-Allow-Origin`字段。
        * `Access-Control-Allow-Origin: https://www.my-site.com` （允许特定源）
        * `Access-Control-Allow-Origin: *` （允许所有源，但 credential 请求不能使用）浏览器看到这个响应头，比对成功，就会放开限制。
2. **非简单请求（预检请求）**：
    - **条件**：使用了`PUT、DELETE、CONNECT`等方法，或`Content-Type`是`application/json`等，或者有自定义头。
    - **<font style="color:rgb(15, 17, 21);">预检请求就是浏览器在发送“危险”的跨域请求前，向服务器申请许可的一道必经安检程序</font>**<font style="color:rgb(15, 17, 21);">。</font>
    - **过程**：
        * **1. 发送预检请求**：在实际请求发送之前，浏览器会先自动发送一个 **OPTIONS **方法的**预检请求**（Preflight Request）到服务器，询问是否允许实际请求。

```http
OPTIONS /users HTTP/1.1
Host: api.other-site.com
Origin: https://www.my-site.com  // 当前页面的源
Access-Control-Request-Method: POST // 声明即将使用的HTTP方法
Access-Control-Request-Headers: content-type, authorization // 声明即将使用的非简单头
```

        * **2. 服务器响应预检**：服务器需要响应这个OPTIONS请求，返回一系列`CORS`头部：
            + `Access-Control-Allow-Origin`: 允许的源
            + `Access-Control-Allow-Methods`: 允许的实际请求方法（如 `GET, POST, PUT`）
            + `Access-Control-Allow-Headers`: 允许携带的自定义头

```http
HTTP/1.1 204 No Content // 对OPTIONS请求的成功响应通常无 body
Access-Control-Allow-Origin: https://www.my-site.com // 允许的源，或 *
Access-Control-Allow-Methods: POST, GET, OPTIONS, DELETE // 允许的方法
Access-Control-Allow-Headers: Content-Type, Authorization // 允许客户端携带的头
Access-Control-Max-Age: 86400 // (可选) 告诉浏览器可以将预检结果缓存多久，单位秒
```

        * **3. 发送实际请求**：浏览器收到预检响应并通过后，会检查`Origin，Method，Headers`是否都在服务器允许的范围内，如果全部允许，才会发送真正的请求。后续过程同简单请求。

```http
POST /users HTTP/1.1
Host: api.other-site.com
Origin: https://www.my-site.com
Content-Type: application/json
Authorization: Bearer token123

{"name": "John"}
```



**后端示例（Node.js/Express）**：

```javascript
const express = require('express');
const app = express();

// 简单的CORS中间件
app.use((req, res, next) => {
  // 允许来自所有域的请求（生产环境应指定具体域名，如：https://www.my-site.com）
  res.header('Access-Control-Allow-Origin', '*');
  // 允许的请求头
  res.header('Access-Control-Allow-Headers', 'Origin, X-Requested-With, Content-Type, Accept, Authorization');
  // 允许的HTTP方法
  res.header('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, OPTIONS');

  // 处理预检请求
  if (req.method === 'OPTIONS') {
    return res.sendStatus(200);
  }
  next();
});

// ... 你的API路由
app.get('/api/data', (req, res) => {
  res.json({ message: 'This is CORS-enabled!' });
});

app.listen(3000);
```

也可以使用现成的 `cors` 中间件包：

pnpm install cors

```javascript
const cors = require('cors');
app.use(cors()); // 使用默认配置（允许所有源）
```

#### 方法二：反向代理
在**开发环境**下非常常用且无需后端大量修改的解决方案，由前端开发工具（如Webpack DevServer、Vite）提供。

**原理**：浏览器同源策略只针对“浏览器->服务器”的请求。代理服务器位于你的本地开发服务器和目标API服务器之间。你让浏览器请求**同源**的本地开发服务器（`http://localhost:8080/api`），本地服务器再**偷偷地**去请求真正的目标服务器（`https://api.other-site.com`），拿到数据后再转发给浏览器。因为服务器-to-服务器之间的请求不受同源策略限制，所以成功了。

**Webpack DevServer 配置示例**：

```plain
// vue.config.js 或 webpack.config.js
module.exports = {
  devServer: {
    proxy: {
      '/api': { // 匹配所有以 '/api' 开头的请求
        target: 'https://api.other-site.com', // 目标API地址
        changeOrigin: true, // 改变请求头中的Host为目标地址的origin
        pathRewrite: {
          '^/api': '' // 重写路径，将 /api 前缀替换为空
        }
      }
    }
  }
};
```

这样，你在前端代码中请求 `/api/users`，实际上会被代理到 `https://api.other-site.com/users`。

#### 方法三：JSONP
一种古老的跨域方案，**只支持GET请求**，现在已不常用。

**原理**：利用`标签没有跨域限制的特点。前端定义一个回调函数（如`handleResponse`），然后动态创建一个`标签，其`src`指向API地址并附带一个回调函数名参数（如`?callback=handleResponse`）。服务器接收到请求后，不是返回JSON，而是返回一段**调用这个回调函数的JS代码**，将数据作为参数传入（如`handleResponse({"data": "some data"})`）。浏览器接收到这段JS代码后会立即执行，从而触发前端定义的回调函数，数据就成功传递了。

**缺点**：仅限GET，错误处理困难，安全性问题（相当于信任并执行了第三方返回的任意JS代码）。

---

### 总结与选择
| 方法 | 适用场景 | 优点 | 缺点 |
| :--- | :--- | :--- | :--- |
| **CORS** | **生产环境首选**，前后端分离项目 | 功能强大，支持所有HTTP方法，是W3C标准 | 需要后端服务器支持配置 |
| **反向代理** | **开发环境首选**，本地调试 | 前端可独立配置，无需修改后端代码，模拟生产环境 | 主要用于开发阶段，生产环境需用Nginx等实现 |
| **JSONP** | 老旧项目，只支持GET的简单场景 | 兼容老式浏览器 | 仅支持GET，不安全，逐渐被淘汰 |


**其他方法（了解即可）**：

+ **Nginx反向代理**：和生产环境下的反向代理原理相同，通过配置Nginx来实现代理转发。
+ **WebSocket**：WebSocket协议本身允许跨域。
+ **postMessage**：主要用于不同窗口/iframe间的跨域通信，不用于API请求。

**最终建议**：

+ 在现代Web开发中，**CORS是解决跨域问题的标准方案和终极方案**。
+ 在开发阶段，为了便捷，可以使用**反向代理**（如Webpack或Vite的代理功能）来避免CORS问题。
+ 尽量避免使用JSONP。

