
### NPM 的幽灵依赖问题
#### 核心定义
**幽灵依赖**，也常被称为**幻影依赖**，指的是在一个 npm 包项目中，你的代码直接引用了某个并未在你项目的 `package.json` 文件的 `dependencies`（或 `devDependencies`）字段中声明的包。

换句话说，你使用了一个库（例如 `lodash`），但这个库并不是你亲自安装的，而是作为**另一个你明确安装的依赖包的依赖**，被间接地安装到了你的 `node_modules` 目录里。

#### 问题是如何产生的？
要理解这个问题，必须了解 npm 的 **node_modules 扁平化结构**（在 npm v3 及之后版本）。

1. **嵌套结构（npm v2）**：早期，`node_modules` 是严格嵌套的。每个包的依赖都在其自身的 `node_modules` 文件夹内。这样不会出现幽灵依赖，因为你的代码根本无法访问到那些嵌套很深的、不属于你的直接依赖。
2. **扁平化结构（npm v3+）**：为了解决嵌套过深和路径过长的问题，npm v3 引入了扁平化算法。它会将依赖尽可能地提升（hoist）到项目根目录的 `node_modules` 中。

**正是这个“提升”操作，创造了幽灵依赖的温床。**

#### 一个具体的例子
假设你的项目 `my-app` 只安装了一个依赖包 `awesome-package`。

1. 你的`package.json`:

```json
{
  "name": "my-app",
  "dependencies": {
    "awesome-package": "^1.0.0"
  }
}
```

而 `awesome-package` 自身又依赖了 `lodash@^4.17.0`。

2. 安装后的结构：  
当你运行 `npm install` 后，npm 的安装算法会尝试进行扁平化。最终，你的 `node_modules` 目录结构可能看起来像这样：

```json
node_modules/
├── awesome-package/    # 你明确安装的包
└── lodash/            # 被 hoist 上来的 `awesome-package` 的依赖（v4.17.21）
```

`lodash` 被提升到了与 `awesome-package` 同级的位置。

3. 幽灵依赖出现：  
现在，在你的项目代码中，你可以直接这样写：

```javascript
// index.js
const _ = require('lodash'); // 或者 import _ from 'lodash';
const awesome = require('awesome-package');

_.map(...); // 使用 lodash
```

这段代码可以正常运行！ 因为 Node.js 的模块解析机制会沿着路径向上查找 `node_modules`，它在项目根目录的 `node_modules` 里找到了 `lodash`。然而，`lodash`** 并没有出现在你的 **`package.json`** 中**。它成了一个“幽灵”依赖。

#### 幽灵依赖带来的危害
这个问题非常隐蔽且危害巨大，是依赖管理的重大隐患。

1. 依赖不确定性（版本冲突）：  
这是最常见的问题。假设后来你又安装了一个新的直接依赖 `another-package`，而 `another-package` 依赖了 `lodash@^3.0.0`。npm 在安装时会尝试满足所有依赖版本。由于项目根目录的 `node_modules` 只能存在一个版本的 `lodash`，假设这次它决定提升 `lodash@3.0.0`，而将 `lodash@4.x` 嵌套在 `awesome-package` 的 `node_modules` 里。新的结构可能是：

```json
node_modules/
├── awesome-package/
│   └── node_modules/
│       └── lodash/    # v4.17.21，被降级嵌套了
├── another-package/
└── lodash/            # v3.0.0，被提升到了顶部
```

此时，你的代码 `require('lodash')` 会找到顶部的 `v3.0.0`，而 `awesome-package` 内部会使用它自己目录下的 `v4.17.21`。这会导致你的应用程序突然崩溃，因为你的代码是为 `lodash v4` 的 API 编写的，但现在却运行在 `v3` 上。问题难以排查，因为你的 `package.json` 看起来毫无变化。

2. 依赖缺失（致命问题）：  
假设 `awesome-package` 在下一个版本中移除了对 `lodash` 的依赖，或者改用其他工具了。  
当你更新 `awesome-package` 后，由于你的项目并不直接依赖 `lodash`，npm 会毫不犹豫地将 `lodash` 从你的 `node_modules` 中完全移除。  
这将导致你的项目在启动时直接崩溃，报错 `Cannot find module 'lodash'`。你甚至不知道为什么，因为你的 `package.json` 里从来没有过它。

#### 总结
| 方面       | 解释                                                                               |
| :------- | :------------------------------------------------------------------------------- |
| **是什么**  | 代码引用了未在 `package.json` 中声明的、由其他依赖间接带来的包。                                         |
| **根源**   | npm 的 `node_modules` 扁平化安装算法将间接依赖提升到了可被访问的顶层。                                    |
| **危害**   | 1. **版本冲突**导致难以调试的运行时错误。   2. **依赖缺失**导致项目突然崩溃。   3. **安全与合规**风险，漏洞和违规许可证不被察觉。   |
| **解决方案** | 1. 使用 `depcheck` 等工具检测。   2. 换用 **pnpm** 或 **Yarn PnP** 从根源解决。   3. 养成良好的依赖管理习惯。 |

### 更现代的包管理器：Pnpm
PNPM（Performance NPM）以其独特的设计和性能优势，成为目前备受关注的包管理工具。

| 特性维度 | PNPM 的优势体现 | 传统包管理器 (npm/Yarn) 的对比 |
| :--- | :--- | :--- |
| **安装速度** | 利用**硬链接**和**全局存储**，相同依赖跨项目共享，极大减少下载和磁盘写入操作，安装速度通常更快。 | 每个项目独立安装依赖，即使相同依赖也重复下载和存储，速度相对较慢，占用更多磁盘空间。 |
| **磁盘空间效率** | **全局存储**使得同一个版本的依赖在磁盘上只存在一份，所有项目通过**硬链接**共享，显著节省空间。 | 每个项目的依赖都独立存储，即使完全相同的依赖也会在不同项目的 `node_modules` 中重复存储，浪费磁盘空间。 |
| **依赖管理安全性** | **非平铺的 **`node_modules`** 结构**（符号链接）有效避免了**幽灵依赖**（Phantom dependencies）问题。 | **平铺的 **`node_modules`** 结构**（依赖提升）可能导致可以访问未在`package.json`中声明的包（幽灵依赖），带来潜在风险。 |
| **Monorepo 支持** | **内置工作区（Workspace）功能**，能高效处理单仓库多包的项目结构，优化依赖管理和链接。 | 需要借助 Lerna 等第三方工具来实现 Monorepo，配置和依赖管理可能更复杂。 |


#### 什么是**硬链接**与**符号链接？**
让我们用“房子”和“地址”来进行比喻：

1. 硬盘上的物理数据（文件内容） = 一栋真实的房子，硬链接 = 这栋房子的不同大门。
2. 房子可以有前门、后门、侧门。无论你从哪扇门进入，你进入的都是同一栋房子。
	封掉一扇门（删除一个硬链接），你依然可以从其他门进入，房子本身完好无损。
	只有所有门都被封掉后，这栋房子才变得无法访问，并被最终拆除（数据被删除）。所以，硬链接不是“指向”房子的指针，它本身就是一扇通往房子的、实实在在的门。 可以说，硬链接就是文件本身。
3. 符号链接 = 一张写着“房子地址”的纸条。这张纸条本身不是房子，它非常轻便，容易创建。你拿着这张纸条，可以找到真正的房子。如果房子被拆了（原始文件被删），你这张纸条就成了一张废纸（链接断裂）。如果房子搬家了（文件被移动），而纸条上的地址没更新，你同样会找不到它。

#### 🧠 **PNPM 如何工作**
PNPM 的高效和节省空间，主要得益于其**硬链接（Hard Links）** 与**符号链接（Symbolic Links）** 的结合，以及**全局存储（Global Store）** 机制。

1. **全局存储（Store）**：当你安装一个依赖包时，PNPM 会首先将其内容下载并存储在本地一个全局的、内容可寻址的存储中心（通常在用户主目录下的 `.pnpm-store` 文件夹中）。**同一个版本的包在磁盘上只存储一次**。
2. **硬链接（Hard Links）**：在为一个新项目安装相同的依赖包时，PNPM 直接**从全局存储创建硬链接到项目的 `node_modules/.pnpm`。硬链接几乎不占用额外的磁盘空间，<font style="color:rgb(15, 17, 21);">因为它只是增加了一个指向原始数据块的记录；</font><font style="color:rgb(15, 17, 21);">不同项目访问的实际上是磁盘上的同一份物理数据</font>。
3. **符号链接（Symbolic Links）与依赖结构**：PNPM 会维护一个**非平铺的、更符合依赖真实关系的 **`node_modules`** 目录结构**。每个包的依赖项会被符号链接到其对应的位置（通常是 `.pnpm` 文件夹内）：  
  
<font style="color:rgb(15, 17, 21);">项目的直接依赖（比如 </font>`<font style="color:rgb(15, 17, 21);background-color:rgb(235, 238, 242);">lodash</font>`<font style="color:rgb(15, 17, 21);">）会通过一个</font>**<font style="color:rgb(15, 17, 21);">符号链接</font>**<font style="color:rgb(15, 17, 21);">，链接到 </font>`<font style="color:rgb(15, 17, 21);background-color:rgb(235, 238, 242);">node_modules/.pnpm</font>`<font style="color:rgb(15, 17, 21);"> 目录下的对应位置（而那个位置的文件又是硬链接到全局 Store 的）。  
  
</font><font style="color:rgb(15, 17, 21);">一个包的自己本身的依赖项会被符号链接到它自己的 </font>`<font style="color:rgb(15, 17, 21);background-color:rgb(235, 238, 242);">node_modules</font>`<font style="color:rgb(15, 17, 21);"> 文件夹下。例如，</font>`<font style="color:rgb(15, 17, 21);background-color:rgb(235, 238, 242);">package-a</font>`<font style="color:rgb(15, 17, 21);"> 依赖 </font>`<font style="color:rgb(15, 17, 21);background-color:rgb(235, 238, 242);">lodash</font>`<font style="color:rgb(15, 17, 21);">，那么 </font>`<font style="color:rgb(15, 17, 21);background-color:rgb(235, 238, 242);">node_modules/.pnpm/package-a@1.0.0/node_modules/lodash</font>`<font style="color:rgb(15, 17, 21);"> 就是一个指向正确 </font>`<font style="color:rgb(15, 17, 21);background-color:rgb(235, 238, 242);">lodash</font>`<font style="color:rgb(15, 17, 21);"> 版本的符号链接。  
  
</font><font style="color:rgb(15, 17, 21);">这种结构保证了你的代码只能访问到在 </font>`<font style="color:rgb(15, 17, 21);background-color:rgb(235, 238, 242);">package.json</font>`<font style="color:rgb(15, 17, 21);"> 中明确声明的包（因为它们被符号链接到了根目录的 </font>`<font style="color:rgb(15, 17, 21);background-color:rgb(235, 238, 242);">node_modules</font>`<font style="color:rgb(15, 17, 21);">），而它们的依赖则被安全地隔离在 </font>`<font style="color:rgb(15, 17, 21);background-color:rgb(235, 238, 242);">.pnpm</font>`<font style="color:rgb(15, 17, 21);"> 文件夹内，你的代码无法直接访问，从而根除了幽灵依赖。</font>

<font style="color:rgb(15, 17, 21);"></font>

<font style="color:rgb(15, 17, 21);">来看一个例子进一步理解 PNPM 项目的 node_modules 文件结构：</font>

```json
node_modules/
├── .pnpm/            -> 存储着你项目所有的依赖（直接依赖和间接依赖），通过硬链接指向全局储存
│   ├── lodash@4.17.21/
│   │   └── node_modules/
│   │       └── lodash/       -> 全局 Store 的硬链接
│   ├── @vue+reactivity@3.3.4/
│   │   └── node_modules/
│   │       ├── @vue/reactivity/ -> 全局 Store 的硬链接
│   │       └── ...（它的依赖）
│   └── ...（其他所有间接依赖）
│
├── lodash -> ./.pnpm/lodash@4.17.21/node_modules/lodash		 -> 符号链接
└── @vue/ -> ./.pnpm/@vue+reactivity@3.3.4/node_modules/@vue			-> 符号链接
```

<font style="color:rgb(15, 17, 21);">假设你的代码执行 </font>`<font style="color:rgb(15, 17, 21);background-color:rgb(235, 238, 242);">import { ref } from '@vue/reactivity'</font>`<font style="color:rgb(15, 17, 21);">：</font>

1. <font style="color:rgb(15, 17, 21);">Node.js 在</font><font style="color:rgb(15, 17, 21);"> </font>`<font style="color:rgb(15, 17, 21);background-color:rgb(235, 238, 242);">node_modules/</font>`<font style="color:rgb(15, 17, 21);"> </font><font style="color:rgb(15, 17, 21);">目录下寻找</font><font style="color:rgb(15, 17, 21);"> </font>`<font style="color:rgb(15, 17, 21);background-color:rgb(235, 238, 242);">@vue</font>`<font style="color:rgb(15, 17, 21);"> </font><font style="color:rgb(15, 17, 21);">文件夹。</font>
2. <font style="color:rgb(15, 17, 21);">它找到</font><font style="color:rgb(15, 17, 21);"> </font>`<font style="color:rgb(15, 17, 21);background-color:rgb(235, 238, 242);">node_modules/@vue/</font>`<font style="color:rgb(15, 17, 21);">（这是一个符号链接），并跟随它指向的实际路径。</font>
3. <font style="color:rgb(15, 17, 21);">这个链接指向的是</font><font style="color:rgb(15, 17, 21);"> </font>`<font style="color:rgb(15, 17, 21);background-color:rgb(235, 238, 242);">./.pnpm/@vue+reactivity@3.3.4/node_modules/@vue/reactivity</font>`<font style="color:rgb(15, 17, 21);">（假设版本是3.3.4）。</font>
4. <font style="color:rgb(15, 17, 21);">最终，它在这个位置找到了包的实体文件（这些文件是硬链接到全局 Store 的）。</font>
5. <font style="color:rgb(15, 17, 21);">模块被成功加载。</font>

#### 🔧 **PNPM 的其它实用特性**
除了核心优势，PNPM 还提供了一些提升开发体验的功能：

+ **高效的工作区（Workspace）**：用于管理 Monorepo（单仓库多包），能轻松处理多个相关包之间的依赖和链接。
+ **严格的依赖版本控制**：通过 `pnpm-lock.yaml` 文件确保依赖安装的一致性。
+ **离线模式**：支持离线安装，优先使用缓存。



### NPM 发包
1. 设置正确的`package.json`，如：

```json
{
  "name": "@hasonocell/addon", // @<user-name>/<package-name>使得包名携带上 scope，避免重名
  "version": "1.0.0",
  "main": "lib/index.js",
  "types": "lib/index.d.ts",
  "scripts": {
    "build": "tsc",
    "format": "prettier --write \"src/**/*.ts\" \"src/**/*.js\"",
    "lint": "tslint -p tsconfig.json"
  },
  "keywords": [],
  "author": "HasonoCell",
  "license": "ISC",
  "description": "Message Tool Based On postMessage API",
  "devDependencies": {
    "@types/uuid": "^10.0.0",
    "prettier": "^3.5.3",
    "tslint": "^5.20.1",
    "tslint-config-prettier": "^1.18.0",
    "typescript": "^5.8.2"
  },
  "dependencies": {
    "mitt": "^3.0.1",
    "uuid": "^8.3.0"
  },
  "publishConfig": {
    "access": "public",
    "registry": "https://registry.npmjs.org/"
  }
}
```

2. 执行`npm login`，登录你的账号
3. 执行`npm publish --access public`，将包发布为公共包

