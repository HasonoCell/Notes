# File 和 Blob
`File` 和 `Blob` 都是原生的 JavaScript 对象，用于处理数据。

`Blob`：表示不可变的原始数据，通常用于创建并处理**二进制数据块**，如通过 File 对象产生的切片等等。

```javascript
const blob = new Blob(['Hello World'], { type: 'text/plain' });
console.log(blob.size); // 11
console.log(blob.type); // "text/plain"

const chunk = file.slice(start, end) // 通过一个 File 对象切片返回 Blob
```

`File`：用于处理用户通过表单上传的**完整文件**。**File 对象是 Blob 对象的子类**，继承了 Blob 的所有属性和方法。File 扩展了 Blob，添加了文件相关的特定信息：文件名 `name` 和文件最后修改时间 `lastModified`

```javascript
// 从 input 获取的文件
const file = input.files[0];
console.log(file.name);         // "example.txt"
console.log(file.size);         // 文件大小
console.log(file.type);         // MIME 类型
console.log(file.lastModified); // 时间戳
```

# Form-Data
`Form-Data`是浏览器提供的一个 API，用来支持文件上传＋混合表单数据的场景。创建一个 Form-Data 有如下两种方式：

```javascript
// 方式1：空对象
const formData = new FormData();

// 方式2：基于表单元素
const form = document.getElementById('myForm');
const formData = new FormData(form);
```

后续的操作基于方式一，即创建一个 Form-Data 空对象再手动 append 数据的方式来讲解。append 方法可以将不同类型的数据（比如 File，String，Number）统一转换为 Form-Data

```javascript
// append 方法的第一个参数是字段名。第二个参数是对应的数据
formData.append('file', file)
formData.append('filename', file.name)
formData.append('index', 100)
```

当构造完 `Form-Data` 对象后，就可以通过网络进行数据交互了。我们知道，网络中传输的数据需要遵守对应的HTTP 数据传输格式规范，比如你想通过网络传输一个 `JSON` 数据，那就需要遵循 `application/json`这一数据传输格式规范`(JSON.stringify(data))`。同样，你想通过网络传输一个 `Form-Data`数据，就需要遵循 `multipart/form-data` 这一格式规范。通常，Form-Data 对象会自动以 multipart/form-data 格式编码数据。（前端注意设置 Content-Type: multipart/form-data 哦）。

```http
POST /upload HTTP/1.1
Content-Type: multipart/form-data; boundary=----WebKitFormBoundaryABC123

------WebKitFormBoundaryABC123
Content-Disposition: form-data; name="username"

张三
------WebKitFormBoundaryABC123
Content-Disposition: form-data; name="avatar"; filename="photo.jpg"
Content-Type: image/jpeg

<图片二进制数据>
------WebKitFormBoundaryABC123--
```
# 切片上传
## 一般的切片上传
1. 确定每个分片的文件大小 CHUNK_SIZE
2. 确定总分片的数量 Math.ceil(file.size / CHUNK_SIZE) 和 Promises 数组
3. 开启一个 for 循环，每次循环内创建一个 FormData，存入 chunk，总文件名，chunk 索引；Promises 数组 push 进去一个对上述 FormData 的 fetch
4. Promise.all 等待数组结果
5. 通知后端切片传输完成，发送文件名和切片总数

要点：**两次POST，第一次是在上传过程中对切片的POST，第二次是结束后通知后端的POST**

```tsx
import { useRef } from "react";

const CHUNK_SIZE = 2 * 1024 * 1024;

const uploadFile = async (file: File) => {
  const chunkCount = Math.ceil(file.size / CHUNK_SIZE);
  const uploadPromises = [];

  for (let i = 0; i < chunkCount; i++) {
    const start = i * CHUNK_SIZE;
    const end = Math.min(file.size, start + CHUNK_SIZE);
    const chunk = file.slice(start, end);

    const formData = new FormData();
    formData.append("file", chunk);
    formData.append("filename", file.name);
    formData.append("index", i.toString());

    uploadPromises.push(
      fetch("http://localhost:3000/upload-chunk", {
        method: "POST",
        body: formData,
      })
    );
  }

  await Promise.all(uploadPromises);

  await fetch("http://localhost:3000/merge-chunks", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      filename: file.name,
      total: chunkCount,
    }),
  });
};

const ChunkUploader = () => {
  const inputRef = useRef<HTMLInputElement>(null);

  const handleUpload = async () => {
    const file = inputRef.current?.files?.[0];
    if (!file) return;
    await uploadFile(file);
    alert("切片上传完成");
  };

  return (
    <div>
      <h2>切片上传</h2>
      <input type="file" ref={inputRef} />
      <button onClick={handleUpload}>上传</button>
    </div>
  );
};

export default ChunkUploader;
```

## 使用并发池的切片上传
为什么需要使用并发池？使用并发池`（concurrentPool）`优化分片上传，主要有以下几个原因：

1. **提升上传效率**  
如果每次只上传一个分片，整体上传速度会很慢。并发池允许同时上传多个分片，大大提高了带宽利用率和上传速度。
2. **防止浏览器或服务器压力过大**  
如果不加限制，直接同时上传所有分片，可能会导致浏览器卡顿、内存暴涨，甚至服务器压力过大，出现拒绝服务等问题。并发池可以限制同时进行的上传任务数量（如3个），让系统资源可控。
3. **便于失败重试**  
并发池实现中可以为每个任务设置重试机制，部分分片上传失败时自动重试，提高整体上传的成功率和健壮性。
4. **更好的用户体验**  
合理的并发数既能保证上传速度，又不会让用户设备变卡，提升体验。



并发池的实现过程可以分为以下几个关键步骤：

1. **准备结果数组和任务索引**
    - `results: T[] = []` 用于存放每个任务的执行结果，保证顺序与 tasks 一致。
    - `let nextTaskId = 0` 用于分配下一个要执行的任务索引。
2. **定义带重试的任务执行函数**
    - `runWithRetry` 是一个异步函数，负责执行指定索引的任务。
    - 如果任务失败，会自动重试，最多 `retryLimit` 次，超过后抛出异常。
    - 成功后将结果存入 `results[taskId]`。
3. **创建 worker 并发执行任务**
    - 创建 `poolLimit` 个 worker，每个 worker 是一个异步函数。
    - 每个 worker 循环领取任务（通过 `nextTaskId++`），直到所有任务分配完毕。
    - 每领取到一个任务，就调用 `runWithRetry` 执行。
4. **等待所有 worker 完成**
    - 使用 `await Promise.all(workers)` 等待所有 worker 执行完毕，确保所有任务都已完成。
5. **返回所有任务结果**
    - 返回 `results` 数组，包含所有任务的执行结果，顺序与 tasks 保持一致。


**简要流程图：**

多个 worker 并发领取任务 → 每个任务失败自动重试 → 所有任务完成后返回结果

```tsx
import { useRef } from "react";

const CHUNK_SIZE = 2 * 1024 * 1024;

// 并发池工具函数
async function concurrentPool<T>(
  tasks: (() => Promise<T>)[],
  poolLimit: number,
  retryLimit: number = 3
): Promise<T[]> {
  const results: T[] = [];
  let nextTaskIndex = 0;

  // 包装带重试的任务
  const runWithRetry = async (taskIndex: number): Promise<void> => {
    let attempt = 0;
    while (attempt < retryLimit) {
      try {
        results[taskIndex] = await tasks[taskIndex]();
        return;
      } catch (err) {
        attempt++;
        if (attempt >= retryLimit) throw err;
      }
    }
  };

  // 启动 worker
  const workers = Array(poolLimit).fill(0).map(async () => {
    while (true) {
      const taskId = nextTaskId++;
      if (taskId >= tasks.length) {
        break; // 没有更多任务了，worker 退出
      }
      await runWithRetry(taskId);
    }
  });

  await Promise.all(workers);
  return results;
}

const uploadFile = async (file: File) => {
  const chunkCount = Math.ceil(file.size / CHUNK_SIZE);
  const tasks: (() => Promise<Response>)[] = [];

  for (let i = 0; i < chunkCount; i++) {
    const start = i * CHUNK_SIZE;
    const end = Math.min(file.size, start + CHUNK_SIZE);
    const chunk = file.slice(start, end);

    const formData = new FormData();
    formData.append("file", chunk);
    formData.append("filename", file.name);
    formData.append("index", i.toString());

    tasks.push(() =>
      fetch("http://localhost:3000/upload-chunk", {
        method: "POST",
        body: formData,
      })
    );
  }

  await concurrentPool(tasks, 3, 3);

  await fetch("http://localhost:3000/merge-chunks", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      filename: file.name,
      total: chunkCount,
    }),
  });
};

const ChunkUploader = () => {
  const inputRef = useRef<HTMLInputElement>(null);

  const handleUpload = async () => {
    const file = inputRef.current?.files?.[0];
    if (!file) return;
    await uploadFile(file);
    alert("切片上传完成");
  };

  return (
    <div>
      <h2>切片上传</h2>
      <input type="file" ref={inputRef} />
      <button onClick={handleUpload}>上传</button>
    </div>
  );
};

export default ChunkUploader;
```

# 断点续传
要点：向后端查询哪些分片已经上传 + 使用`continue`在循环中跳过已经上传的部分；一般将此功能整合进切片上传中。

核心代码：

```tsx
const uploadFileWithResume = async (file: File) => {
  const chunkCount = Math.ceil(file.size / CHUNK_SIZE);

  // 查询已上传分片
  const res = await fetch(
    `http://localhost:3000/uploaded-chunks?filename=${encodeURIComponent(
      file.name
    )}`
  );
  const uploadedChunks: number[] = await res.json();

  const tasks: (() => Promise<Response>)[] = [];

  for (let i = 0; i < chunkCount; i++) {
    if (uploadedChunks.includes(i)) continue; // 跳过已上传分片

    const start = i * CHUNK_SIZE;
    const end = Math.min(file.size, start + CHUNK_SIZE);
    const chunk = file.slice(start, end);

    const formData = new FormData();
    formData.append("file", chunk);
    formData.append("filename", file.name);
    formData.append("index", i.toString());

    tasks.push(() =>
      fetch("http://localhost:3000/upload-chunk", {
        method: "POST",
        body: formData,
      })
    );
  }

  // 并发上传未上传的分片
  await concurrentPool(tasks, 3, 3);

  // 合并分片
  await fetch("http://localhost:3000/merge-chunks", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify({
      filename: file.name,
      total: chunkCount,
    }),
  });
};
```

