# 浏览器是如何渲染页面的？
在此之前，先解释一下**进程和线程**的概念。

进程（Process）是操作系统分配资源（如内存、CPU时间等）的基本单位。每个运行中的程序就是一个进程，进程之间相互独立。

线程（Thread）是进程中的执行单元，是CPU调度的基本单位。一个进程可以包含多个线程，这些线程共享进程的资源，但可以并发执行。



现代浏览器采用**多进程架构**，每个进程内部又包含多个线程。具体来说：

+ **浏览器有多个进程**，比如主进程、渲染进程、GPU 进程、插件进程等。
+ 每个进程内部有多个线程，例如渲染进程中有：
    - GUI 渲染线程
    - JS 引擎线程
    - 事件触发线程
    - 定时器线程
    - 网络请求线程等



当浏览器的**网络进程**收到 HTML 文档后，会产生一个渲染任务交给**渲染进程**，此进程将任务继续传递给**渲染主线程**的任务队列。在事件循环机制的作用下，渲染主线程取出任务队列中的渲染任务，开启渲染流程。

## 一，构建 DOM 和 CSSOM 树
解析过程中如果遇到 CSS 解析 CSS，遇到 JS 执行 JS。为了提高解析效率，浏览器在开始解析之前，会启动一个**预解析的线程**，率先下载 HTML 中的外部 CSS 文件 和 JS 文件。

如果主线程解析到 `link`标签位置，此时外部的 CSS 文件还没有下载解析好，主线程不会等待，继续解析后续的 HTML。这是因为下载和解析 CSS 的工作是在预解析线程中进行的。这就是 CSS 不会阻塞 HTML 解析的根本原因。

![](https://cdn.nlark.com/yuque/0/2025/png/53866714/1752134079909-37a7f69b-d6c1-48f3-88d6-5f7c56b7c3de.png)

如果主线程解析到 **script** 标签位置，会停止解析 HTML，转而等待 JS 文件下载好，并将全局代码解析执行完成后，再继续解析 HTML。这是因为 JS 代码的执行过程可能会修改当前的 DOM 树，所以 DOM 树的生成必须暂停。这就是 JS 会阻塞 HTML 解析的根本原因。

![](https://cdn.nlark.com/yuque/0/2025/png/53866714/1752134109154-47ebb036-16ca-4b58-bf06-debaf3fe3fc8.png)

在第一步完成后，会得到 DOM 树和 CSSOM 树，浏览器的默认样式，内部样式表，外部样式表，行内样式均会包含在 CSSOM 树中。

![](https://cdn.nlark.com/yuque/0/2025/png/53866714/1752134120157-cf2531a4-94cf-4505-b820-5e09140f33ba.png)

## 二，构建渲染树
主线程会遍历得到的 DOM 树，依次为树中的每个节点计算出它最终的样式，称之为 **Computed Style**。在这一过程中，很多预设值会变成绝对值，比如 `red` 会变成 `rgb(255,0,0)`；相对单位会变成绝对单位，比如 `em` 会变成 `px`。这一步完成后，会得到一棵渲染树，**渲染树只包含可见的节点**，**如果某个 DOM 节点设置了**`**display: none**`**，那么他将不会存在于渲染树中。**

## 三，布局
布局阶段会依次遍历渲染树的每一个节点，**计算每个DOM节点在视口中展示出来的几何信息与确切位置。**例如节点的宽高、相对包含块的位置。

## 四，分层
渲染主线程会使用一套复杂的策略对整个布局树中进行分层。分层的好处在于，将来某一个层改变后，仅会对该层进行后续处理，从而提升渲染效率。

**滚动条、堆叠上下文、**`transform`**、**`opacity` **等样式都会或多或少的影响分层结果，也可以通过 **`will-change`** 属性更大程度的影响分层结果。**

我们可以在浏览器调试工具的更多工具 -> 图层来查看当前分层的结果。

![](https://cdn.nlark.com/yuque/0/2025/png/53866714/1752135544477-01616a1d-4e96-4b59-9776-036d991461ac.png)

![](C:\Users\Hasono\Desktop\笔记\笔记图片\浏览器渲染原理\分层.png)

## 五，绘制
渲染主线程会为每个层单独**产生绘制指令集**，用于描述这一层的内容该如何画出来。完成绘制后，主线程将每个图层的绘制信息提交给合成线程，剩余工作将由合成线程完成。

!![](https://cdn.nlark.com/yuque/0/2025/png/53866714/1752135569977-91599a7b-6cac-4da5-a982-659843821217.png)

!![](https://cdn.nlark.com/yuque/0/2025/png/53866714/1752135614523-72151950-9736-4964-a61b-73394cd4d159.png)



# 面试题
## 什么是 reflow（重排）？
`reflow`的本质就是重新进行布局。在读取元素的几何信息（比如`offsetHeight, clientHeight`）时，<font style="color:rgb(15, 17, 21);">为了给前端返回</font>**<font style="color:rgb(15, 17, 21);">精确的、最新的尺寸值</font>**<font style="color:rgb(15, 17, 21);">，必须保证当前的计算是基于最新的布局状态。如果在此之前有样式修改，浏览器会</font>**<font style="color:rgb(15, 17, 21);">强制同步执行重排</font>**<font style="color:rgb(15, 17, 21);">来确保数据的准确性。也就是说，</font>**<font style="color:#DF2A3F;">读取几何信息，则立即开始重排。</font>**

```javascript
// 不好的写法：读写交错，导致多次重排
const element = document.getElementById('myElement');

element.style.width = '100px';    // 样式修改（标记需要重排）
const height1 = element.offsetHeight; // 读取 → 强制重排！

element.style.height = '200px';   // 样式修改
const height2 = element.offsetHeight; // 读取 → 再次强制重排！
```

```javascript
// 好的写法：先批量写，再批量读
const element = document.getElementById('myElement');

// 1. 先进行所有样式修改
element.style.width = '100px';
element.style.height = '200px';

// 2. 再一次性读取所有需要的尺寸信息
const height = element.offsetHeight;
const width = element.offsetWidth;
```

## 什么是 repaint（重绘）？
`repaint`的本质就是重新根据分层信息计算了绘制指令。当改动了可见样式后，就需要重新计算，会引发 `repaint`。由于元素的布局信息也属于可见样式，所以 `reflow` 一定会引起 `repaint`。

## 为什么 transform 的效率高？
因为`transform`属性的执行时机发生于合成线程中，**不会阻塞渲染主线程的执行。**

