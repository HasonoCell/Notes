HTTP 缓存是一种强大的技术，通过存储资源的副本，在后续请求时复用它们，从而显著提升网站性能、减少服务器负载和带宽消耗。其核心机制分为两类：

---

### 1. 强制缓存 (Strong Cache)
**核心思想**：在缓存数据未失效的情况下，浏览器**根本不会**与服务器进行通信，直接使用本地缓存。这个过程发生在 `Network` 选项卡中，你会看到状态码为 `200` 且后面跟着 `(from disk cache)` 或 `(from memory cache)` 的请求。

**如何实现**：服务器通过响应头来告诉浏览器资源的“有效期”。

#### 常用响应头：
1. `Cache-Control` (HTTP/1.1 标准，**优先级更高**)
    - `max-age=`： 单位是秒。例如 `max-age=3600` 表示资源在 3600 秒（1小时）内有效。
    - `public`： 响应可以被任何对象（客户端、代理服务器等）缓存。
    - `private`： 响应只能被单个用户（浏览器）缓存，不能被代理服务器等共享缓存。
    - `no-cache`： **不是不缓存**，而是**使用缓存前，必须先向服务器验证**（即跳过强制缓存，直接进入协商缓存流程）。
    - `no-store`： **真正的不缓存**，每次都要从服务器重新获取。
2. `Expires` (HTTP/1.0 标准，已逐步被取代)
    - 指定一个具体的过期时间点（GMT 格式），例如 `Expires: Wed, 21 Oct 2022 07:28:00 GMT`。
    - **缺点**： 依赖客户端时间，如果用户修改了本地时间，会导致缓存失效或永久有效。

**Node.js 服务器端代码示例 (设置强制缓存)**：

```javascript
const http = require('http');
const fs = require('fs');

http.createServer((req, res) => {
  if (req.url === '/script.js') { // 假设请求一个 JS 文件
    // 读取文件
    let filePath = './script.js';
    let stat = fs.statSync(filePath);

    // 设置 Cache-Control 头，有效期 60 秒
    res.setHeader('Cache-Control', 'max-age=60');
    // 或者设置 Expires 头 (已被 Cache-Control 覆盖，此处仅为演示)
    res.setHeader('Expires', new Date(Date.now() + 60000).toUTCString());

    // 读取并返回文件内容
    let stream = fs.createReadStream(filePath);
    stream.pipe(res);
  }
}).listen(3000);

console.log('Server running at http://localhost:3000/');
```

**浏览器行为**：  
在 60 秒内，浏览器再次访问 `/script.js` 时，不会向服务器发送任何请求，直接从本地磁盘或内存加载。

---

### 2. 协商缓存 (Conditional Cache / Validation Cache)
**核心思想**：浏览器**总是会向服务器发起请求**。服务器会检查请求中的“验证字段”，判断本地缓存是否依然有效。如果有效，服务器返回 `304 Not Modified` 状态码，并且**不返回资源内容**，浏览器则使用本地缓存。如果无效，服务器返回 `200 OK` 和新的资源内容。

这个过程需要一对请求头/响应头配合工作。

#### 常用字段对：
1. `Last-Modified`** / **`If-Modified-Since`
    - **服务器响应头**： `Last-Modified: GMT_date` (资源的最后修改时间)。
    - **浏览器下次的请求头**： `If-Modified-Since: GMT_date` (将上次收到的 `Last-Modified` 值发回给服务器)。
    - **服务器检查**： 对比请求头中的 `If-Modified-Since` 和服务器上该资源的实际最后修改时间。
    - **缺点**： 时间精度为秒，如果文件在1秒内改变，无法识别；可能文件内容没变，但修改时间变了（如 touch 操作）。
2. `ETag`** / **`If-None-Match` (优先级更高，更精确)
    - **服务器响应头**： `ETag: "a_unique_string"` (资源的唯一标识符，通常是文件内容的哈希值或版本号)。
    - **浏览器下次的请求头**： `If-None-Match: "a_unique_string"` (将上次收到的 `ETag` 值发回给服务器)。
    - **服务器检查**： 对比请求头中的 `If-None-Match` 和服务器上该资源当前生成的 `ETag` 是否一致。
    - **优点**： 能非常精确地感知内容的变化。

**流程图**：

![](https://cdn.nlark.com/yuque/__mermaid_v3/0dd43c868f435a31c040910c5b2cb199.svg)

**Node.js 服务器端代码示例 (设置协商缓存)**：

```javascript
const http = require('http');
const fs = require('fs');
const crypto = require('crypto');

http.createServer((req, res) => {
  if (req.url === '/style.css') { // 假设请求一个 CSS 文件

    let filePath = './style.css';
    // 生成当前文件的 ETag (简易实现，生产环境可用更严谨的方法)
    let fileBuffer = fs.readFileSync(filePath);
    let hash = crypto.createHash('md5').update(fileBuffer).digest('hex');
    let currentETag = `"${hash}"`;

    // 获取浏览器请求头中携带的 If-None-Match
    let clientIfNoneMatch = req.headers['if-none-match'];

    // 进行 ETag 对比
    if (clientIfNoneMatch === currentETag) {
      // 缓存有效，返回 304
      res.statusCode = 304;
      res.end();
    } else {
      // 缓存失效或第一次请求，返回新内容和 ETag
      res.setHeader('ETag', currentETag);
      // 也可以同时设置 Last-Modified
      let stat = fs.statSync(filePath);
      res.setHeader('Last-Modified', stat.mtime.toUTCString());

      // 返回文件内容
      res.end(fileBuffer);
    }
  }
}).listen(3000);
```

---

### 总结与最佳实践
| 特性 | 强制缓存 | 协商缓存 |
| :--- | :--- | :--- |
| **行为** | 不发送请求，直接用缓存 | 发送请求，由服务器判断是否用缓存 |
| **状态码** | `200 (from cache)` | `304 (Not Modified)` |
| **优先级** | 高，先检查强制缓存 | 低，强制缓存失效后才检查 |
| **如何设置** | `Cache-Control`, `Expires` | `ETag`/`If-None-Match`, `Last-Modified`/`If-Modified-Since` |
| **应用场景** | 静态资源（图片、字体、JS、CSS 库） | 频繁变更的 HTML 文件、用户相关数据 |


**实际应用策略（非常常见）**：

对于像 JS，CSS 等打包后的静态文件（带有 Hash 文件名），通常采用 **“Cache-Control: max-age=31536000” (一年)** 的强制缓存。因为文件名哈希与内容强关联，内容一变文件名就变，请求的 URL 也就变了，缓存自然失效。

对于 HTML 文件，通常使用 **“Cache-Control: no-cache”**，让浏览器每次都协商缓存，以便及时获取到最新的资源链接。

