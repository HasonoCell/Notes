### EventEmitter
```typescript
class EventEmitter {
  events: Map<string, Function[]>;

  constructor() {
    this.events = new Map();
  }

  on(event: string, fn: Function) {
    if (!this.events.has(event)) {
      this.events.set(event, []);
    }

    this.events.get(event)?.push(fn);
    return this;
  }

  off(event: string, fn?: Function) {
    // 如果没有指定函数，则移除所有监听器
    if (!fn) {
      this.events.delete(event);
      return this;
    }

    const listeners = this.events.get(event);
    if (listeners) {
      // 过滤掉要移除的函数，同时兼容 once 的情况
      const filtered = listeners.filter(
        (listener) => listener !== fn && (listener as any).origin !== fn
      );

      // 如果过滤后列表为空，则直接删除事件
      if (filtered.length) {
        this.events.set(event, filtered);
      } else {
        this.events.delete(event);
      }
    }

    return this;
  }

  once(event: string, fn: Function) {
    const wrapper = (...args: any[]) => {
      fn(...args);
      // 移除 wrapper 本身而不是 fn
      this.off(event, wrapper);
    };

    // 将原始函数 fn 挂载到 wrapper 的 origin 属性上
    (wrapper as any).origin = fn;

    return this.on(event, wrapper);
  }

  emit(event: string, ...args: any[]) {
    const listeners = this.events.get(event)!;
    // 复制一份再遍历，防止在 emit 过程中修改原始数组导致问题
    if (listeners) {
      [...listeners].forEach((listener) => listener(...args));
    }

    return this;
  }
}
```

### Call, Apply, Bind
call() 方法会立即调用该函数。在调用函数的同时，将函数内部的 this 指向第一个参数指定的对象，后续的参数会作为普通参数逐个传递给原函数。

apply() 方法与 call() 方法的功能几乎完全相同，也是立即调用函数。唯一的区别在于：apply接收参数数组（或类数组对象），而不是参数列表。

bind() 方法与前两者有根本性的不同：它不会立即调用函数，而是创建一个新的函数。这个新函数的 this 被永久地绑定到 bind 的第一个参数，其余参数将作为新函数的预设参数（也称为“部分应用”或“柯里化”）。

```typescript
Function.prototype.call = function (context, ...args) {
  context = context === null ? globalThis : Object(context);
  const symbol = Symbol("fn");

  context[symbol] = this;
  const res = context[symbol](...args);

  Reflect.deleteProperty(context, symbol);
  return res;
};

Function.prototype.bind = function (context, ...bindArgs) {
  const fn = this;

  return function (...callArgs) {
    return fn.call(context, ...bindArgs, ...callArgs);
  };
};
```

### 防抖 / 节流
1. 防抖：频繁触发时只执行最后一次，适合"等用户停下来再执行"的场景，比如输入框实时搜索：用户输入时只在停止输入一段时间后才发起请求，避免每敲一个字都请求一次。

```typescript
const debounce = (delay, fn) => {
  let timer = null;

  return (...args) => {
    clearTimeout(timer);
    timer = setTimeout(() => {
      fn(...args);
    }, delay);
  };
};
```

2. 节流：无论怎么频繁触发都按固定间隔执行，适合"持续响应但控制频率"的场景，比如按钮点击防止多次提交：限制按钮在一定时间内只能点击一次，防止重复提交。

```typescript
const throttle = (delay, fn) => {
  let timer = null;

  return (...args) => {
    if (timer) {
      return;
    }

    timer = setTimeout(() => {
      timer = null;
      fn(...args);
    }, delay);
  };
};
```

### 深浅拷贝
**浅拷贝**：创建一个新对象，但只复制第一层属性。如果属性是引用类型，则复制引用而非实际值。

```typescript
// 1. 扩展运算符
let shallowCopy1 = { ...original };

// 2. Object.assign()
let shallowCopy2 = Object.assign({}, original);

// 3. Array.slice() (对于数组)
let shallowCopy3 = originalArray.slice();
```

演示：

```typescript
let original = { 
  name: "Alice", 
  details: { age: 25, city: "New York" } 
};

let shallowCopy = { ...original };
shallowCopy.name = "Bob"; // 不影响原对象
shallowCopy.details.age = 30; // 会影响原对象

console.log(original.name); // "Alice" (未改变)
console.log(original.details.age); // 30 (被改变了)
```

**深拷贝：**不管有多少层，全部复制

1. JS 内置了一个深拷贝函数：`structuredClone`

```typescript
const original = {
  date: new Date(),
  set: new Set([1, 2, 3]),
  nested: { a: 1 },
};
original.circular = original; // 循环引用

const cloned = structuredClone(original);

console.log(cloned.date !== original.date); // true, 是新的 Date 对象
console.log(cloned.nested !== original.nested); // true, 是新的 object
console.log(cloned.circular === cloned); // true, 循环引用被正确处理
```

2. 自己手写一个深拷贝函数

```typescript
// 1. JSON方法（最简单但有局限性，不能正确处理循环引用）
let deepClone = JSON.parse(JSON.stringify(original));

// 2. 递归函数
const deepClone = (obj: any, map = new Map()): any => {
  if (!obj || typeof obj !== "object") {
    return obj;
  }

  if (obj instanceof Date) return new Date(obj);
  if (obj instanceof RegExp) return new RegExp(obj.source, obj.flags);
  if (obj instanceof Set) return new Set([...obj].map((value) => deepClone(value, map)));
  if (obj instanceof Map)
    return new Map(
      [...obj].map(([key, value]) => [
        deepClone(key, map),
        deepClone(value, map),
      ])
    );

  if (map.has(obj)) {
    return map.get(obj);
  }

  const clone = Array.isArray(obj) ? [] : {};
  map.set(obj, clone);

  for (let key of Reflect.ownKeys(obj)) {
    clone[key] = deepClone(obj[key], map);
  }

  return clone;
};
```

### 自定义深度的 Flat
```typescript
function flat(array, depth = 1) {
  if (!Array.isArray(array)) throw new TypeError("flat expects an array");
  const result = [];

  function flatten(array, depth) {
    for (const item of array) {
      if (Array.isArray(item) && depth > 0) {
        flatten(item, depth - 1);
      } else {
        result.push(item);
      }
    }
  }

  flatten(array, depth);

  return result;
}
```

### Promise
**Promise.all**

```typescript
const promise_all = (promises) => {
  return new Promise((resolve, reject) => {
    const results = [];
    const total = promises.length;
    const promises_arr = Array.from(promises); // 确保处理的是数组
    let completed = 0;

    // 处理边界情况
    if (total === 0) {
      return resolve(results);
    }

    promises_arr.forEach((promise, index) => {
      Promise.resolve(promise).then(
        (value) => {
          results[index] = value;
          completed++;

          if (completed === total) {
            resolve(results);
          }
        },
        (error) => {
          reject(error);
        }
      );
    });
  });
};
```

**Promise.race**

```typescript
const promise_race = (promises) => {
  return new Promise((resolve, reject) => {
    const promises_arr = Array.from(promises);

    promises_arr.forEach((promise) => {
      Promise.resolve(promise).then(
        (value) => {
          resolve(value);
        },
        (error) => {
          reject(error);
        }
      );
    });
  });
};
```

**Promise.allSettled**

```typescript
const promise_allSettled = (promises) => {
  // allSettled 只会返回一个 fulfilled 状态的 Promise
  return new Promise((resolve) => {
    const results = [];
    const total = promises.length;
    const promises_arr = Array.from(promises);
    let completed = 0;

    if (total === 0) {
      resolve(results);
      return;
    }

    promises_arr.forEach((promise, index) => {
      Promise.resolve(promise)
        .then(
          (value) => {
            // 构造成一个信息对象
            results[index] = { status: "fulfilled", value };
          },
          (reason) => {
            results[index] = { status: "rejected", reason };
          }
        )
        .finally(() => {
          completed++;
          if (completed === total) {
            resolve(results);
          }
        });
    });
  });
};
```

### 数字千分位分割
```typescript
const thousandSplit = (num) => {
  const str = num.toString(),
    len = str.length;
  let count = 0,
    arr = [];

  for (let i = len - 1; i >= 0; i--) {
    count++;
    if (count > 3) {
      count = 1;
      arr.push(".");
    }

    arr.push(str[i]);
  }

  return arr.reverse().join("");
};
```

### 数组转树
xx转树的题的基本思路就是：两次遍历，一，先将源数据构造为独立的树节点；二，将独立的树节点连成树。

```typescript
const arr = [
  { id: 1, name: "部门A", parentId: null },
  { id: 2, name: "部门B", parentId: null },
  { id: 3, name: "部门C", parentId: 1 },
  { id: 4, name: "部门D", parentId: 1 },
  { id: 5, name: "部门E", parentId: 2 },
  { id: 6, name: "部门F", parentId: 3 },
  { id: 7, name: "部门G", parentId: 2 },
  { id: 8, name: "部门H", parentId: 4 },
];

const arrayToTree = (arr) => {
  const result = [];
  const map = new Map();

  for (let item of arr) {
    map.set(item.id, { ...item, children: [] });
  }

  for (let item of arr) {
    const id = item.id;
    const parentId = item.parentId;
    const node = map.get(id);

    if (!parentId || !map.has(parentId)) {
      result.push(node);
    } else {
      map.get(parentId).children.push(node);
    }
  }

  return result;
};
```

### 函数柯里化
```typescript
const curry = (fn) => {
  return function curried(...args) {
    if (args.length >= fn.length) {
      return fn(...args);
    }

    return function (...nextArgs) {
      return curried(...args, ...nextArgs);
    };
  };
};
```

### 二分查找
这个算法中，之所以要让`l = mid + 1`，就是为了当 `l` 的下一个位置就是 `r` 时，计算 `mid` 后发现没找到就可以是 `l + 1` 到达与 `r` 相同的位置，不满足循环要求的 `l < r`，从而终止循环。

```typescript
/**
 *
 * @param {Array} arr
 * @param {number} target
 */
const binary_search = (arr, target) => {
  // 假设 arr 是升序排列的
  // 采用左闭右开区间，实际搜索范围是 [l, r - 1]
  let l = 0;
  let r = arr.length;

  while (l < r) {
    let mid = Math.floor((l + r) / 2);
    if (arr[mid] === target) {
      return mid;
    } else if (arr[mid] < target) {
      l = mid + 1;
    } else {
      r = mid;
    }
  }

  return null; // 未找到
};
```

### 缩进字符串转树
```typescript
const parseStrToTree = (str) => {
  // 先去除字符串的首尾空白字符，方便处理
  // 然后通过换行符 \n 分割，同时去除非首位的空白字符
  let lines = str
    .trim()
    .split("\n")
    .filter((line) => line.trim() !== "");

  // 然后将每一个 line 构造为一个 node(value + indentLevel)
  const nodes = lines.map((line) => ({
    value: parseInt(line.trim()),
    indentLevel: line.search(/\S/), // 找到第一个非空白字符的位置
  }));

  // 然后开始构建树，考虑使用栈去遍历和回溯
  const root = { children: [] };
  const stack = [root];

  for (let node of nodes) {
    // -1 是排除虚拟的 root 节点
    while (stack.length - 1 > node.indentLevel) {
      stack.pop();
    }

    // 取栈顶元素
    let parent = stack[stack.length - 1];
    let newNode = { value: node.value, children: [] };

    parent.children.push(newNode);
    stack.push(newNode);
  }

  return root.children;
};

// 测试函数
const str = `
1
  2
    3
4
  5
`;

const tree = parseIndentedStringToTree(str);
console.log(JSON.stringify(tree, null, 2));
```

### 任务调度器 Scheduler
```typescript
type Task = () => Promise<any>;

class Scheduler {
  private prev: Promise<any>;

  constructor() {
    this.prev = Promise.resolve();
  }

  log(message: string) {
    this.prev = this.prev.then(() => console.log(message));
    return this;
  }

  wait(ms: number) {
    this.prev = this.prev.then(() => {
      return new Promise((resolve) => setTimeout(resolve, ms));
    });
    return this;
  }

  run(task: Task, timeoutLimit?: number) {
    this.prev = this.prev.then(() => {
      if (!timeoutLimit) {
        return task();
      }

      let taskPromise = task();
      let timeoutPromise = new Promise((resolve) =>
        setTimeout(resolve, timeoutLimit)
                                      );

      return Promise.race([taskPromise, timeoutPromise]);
    });
    return this;
  }

  parallel(tasks: Task[], parallelLimit?: number) {
    this.prev = this.prev.then(() => {
      if (!parallelLimit) {
        const promises = tasks.map((task) => task());
        return Promise.all(promises);
      }

      return new Promise((resolve) => {
        const total = tasks.length;
        const limit = Math.min(parallelLimit, total);
        const results: any[] = [];
        let taskId = 0;

        const workers = Array(limit)
          .fill(null)
          .map(async () => {
            while (taskId < total) {
              const currentId = taskId++;
              const task = tasks[currentId];
              try {
                results[currentId] = await task();
              } catch (error) {
                results[currentId] = error;
              }
            }
          });

        Promise.all(workers).then(() => resolve(results));
      });
    });
    return this;
  }

  retry(retryLimit: number, task: Task, delay?: number) {
    const attempt = async (retryLeft: number) => {
      try {
        return await task();
      } catch (error) {
        if (retryLeft === 0) {
          throw error;
        }

        if (delay) {
          await new Promise((resolve) => setTimeout(resolve, delay));
        }

        return attempt(retryLeft - 1);
      }
    };

    this.prev = this.prev.then(() => attempt(retryLimit));
    return this;
  }

  done(): Promise<any> {
    return this.prev;
  }
}
```

### new
```typescript
function myNew(constructor: Function, ...args: any[]) {
  // 1. 创建一个新对象,对象的原型指向构造函数的 prototype 属性
  const obj = Object.create(constructor.prototype);

  // 2. 执行构造函数,将 this 绑定到新对象
  const result = constructor.call(obj, ...args);

  // 3. 如果构造函数返回了对象,则返回该对象,否则返回新创建的对象
  return result instanceof Object ? result : obj;
}
```

### CSS 画三角形
```html
<div
  style="
  width: fit-content;
  border: 10px solid transparent;
  border-top-color: red;
  "
  ></div>
```

