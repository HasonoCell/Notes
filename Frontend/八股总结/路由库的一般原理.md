### 一、实现原理
核心目标：**在改变URL的同时，不触发浏览器整体刷新，而是动态地切换页面中渲染的组件或视图。**

为了实现这个目标，所有路由库都遵循着相似的工作流程，可以概括为以下几步：

1. **路由映射**： 定义一个规则（路由表），将不同的URL路径（`path`）映射到相应的视图或组件（`component`）。
    - 例如：`/home` -> `HomeComponent`, `/about` -> `AboutComponent`。
2. **监听变化**： 持续监听浏览器地址栏URL的变化。
    - 用户可能通过点击应用内的`<a>`链接、前进/后退按钮、或者手动输入来改变URL。
3. **匹配规则**： 当URL发生变化时，路由库会根据定义好的路由表，找到与当前URL匹配的规则。
4. **更新视图**： 路由库不会让浏览器刷新页面，而是执行一个回调函数。
    - 在**React**中，通常是`setState`来渲染新的组件。
    - 在**Vue**中，通常是替换`<router-view>`组件中的内容。
    - 这个过程就是“路由切换”。
5. **保持同步**： 确保应用内部的状态（当前渲染的视图）与浏览器地址栏的URL始终保持一致。

---

### 二、用到了哪些底层 API？
路由库的实现模式主要分为两种：**Hash 模式** 和 **History 模式**。它们依赖的底层API不同。

#### 1. Hash 模式 (例如：`http://example.com/#/about`)
利用URL中`#`及其后面的部分（hash）来实现路由。**改变hash部分不会触发浏览器向服务器发送请求**。

+ **关键API**：
    - `window.location.hash`： 这个属性可以获取(`get`)或者设置(`set`)当前URL的hash值。
        * 设置它：`window.location.hash = '/about';`，URL会变成`http://example.com/#/about`，且不会刷新页面。
    - `window.onhashchange` 事件： 当URL的hash部分发生变化时，就会触发这个事件。
        * 这是监听路由变化的核心事件。

**Hash模式的优点**：兼容性极好（IE8+），实现简单。  
**缺点**：URL中有一个不美观的`#`，SEO不友好（但现代搜索引擎如Google已经可以爬取hash内容）。

#### 2. History 模式 (例如：`http://example.com/about`)
利用HTML5的History API来实现，URL看起来和普通的页面一样，更美观。

+ **关键API (HTML5 History API)**:
    - `history.pushState(state, title, url)`： **向历史记录栈中添加一条记录**，并改变地址栏的URL，**但不会触发页面刷新**。
        * `state`: 一个状态对象，与新记录关联，可以通过`history.state`获取。
        * `title`: 新页面的标题（目前大多数浏览器忽略此参数）。
        * `url`: 新的URL（必须同源）。
        * **示例**：`history.pushState({}, '', '/about')`，URL变为`http://example.com/about`，无刷新。
    - `history.replaceState(state, title, url)`： 与`pushState`类似，但它是替换当前的历史记录，而不是添加一条新的。
    - `window.onpopstate` 事件： **当用户点击浏览器的前进或后退按钮**，或者调用`history.back()`, `history.forward()`, `history.go()`方法时，该事件会被触发。
        * **注意**：`history.pushState()`和`history.replaceState()`的调用**不会**触发`popstate`事件。这是History模式需要自己处理路由跳转的原因。

**History模式的优点**：URL美观，与多页应用无异，对SEO更友好。  
**缺点**：需要服务器端支持（因为所有路径都由前端处理，服务器需配置对所有路径返回`index.html`），兼容性稍差（IE10+）。

---

### 三、如何自己实现一个简易的路由库？
我们来实现一个极简的、基于 **History模式** 的路由库，它包含最基本的功能：路由注册、跳转和视图渲染。

#### 步骤1：设计路由表
我们期望这样注册路由：

```javascript
const routes = [
  { path: '/', component: '<div>Home</div>' },
  { path: '/about', component: '<div>About</div>' },
  { path: '/contact', component: '<div>Contact</div>' }
];
```

#### 步骤2：实现核心类 `Router`
```javascript
class MyRouter {
  constructor(routes) {
    this.routes = routes;
    this._loadInitialRoute();
    this._bindPopState();
  }

  // 获取当前URL的路径部分
  getCurrentPath() {
    return window.location.pathname;
  }

  // 加载初始路由（例如用户直接输入URL进入）
  _loadInitialRoute() {
    const path = this.getCurrentPath();
    this.navigateTo(path); // 导航到当前路径
  }

  // 绑定 popstate 事件（处理前进/后退）
  _bindPopState() {
    window.addEventListener('popstate', (e) => {
      // 当popstate事件触发时，获取新的路径并渲染对应组件
      const path = this.getCurrentPath();
      this.navigateTo(path, false); // false 表示不需要pushState，因为浏览器已经自动处理了
    });
  }

  // 核心导航方法
  navigateTo(path, shouldPushState = true) {
    // 1. 匹配路由
    const matchedRoute = this.routes.find(route => route.path === path);

    if (!matchedRoute) {
      // 没找到匹配路由，可以渲染一个404组件
      console.error(`Route for ${path} not found!`);
      return;
    }

    // 2. 如果需要，更新浏览器历史记录
    if (shouldPushState) {
      history.pushState({}, '', path);
    }

    // 3. 更新DOM（这里是极简示例，实际应用中会用更复杂的方式替换组件）
    const appContainer = document.getElementById('app');
    if (appContainer) {
      appContainer.innerHTML = matchedRoute.component;
    }
  }

  // 提供一个方便的跳转方法，比如给<a>标签使用
  goTo(path) {
    this.navigateTo(path);
  }
}
```

#### 步骤3：使用这个路由库
1. **HTML**:

```html
<body>
  <nav>
    <a href="/" onclick="router.goTo('/'); return false;">Home</a>
    <a href="/about" onclick="router.goTo('/about'); return false;">About</a>
    <a href="/contact" onclick="router.goTo('/contact'); return false;">Contact</a>
  </nav>
  <div id="app"><!-- 路由组件将在这里渲染 --></div>
</body>

```

_注意_：我们使用`onclick`并`return false`来阻止`<a>`标签的默认刷新行为。

2. **JavaScript**:

```javascript
// 1. 定义路由
const routes = [
  { path: '/', component: '<h1>Home Page</h1>' },
  { path: '/about', component: '<h1>About Us</h1>' },
  { path: '/contact', component: '<h1>Contact Info</h1>' }
];

// 2. 初始化路由
const router = new MyRouter(routes);

// 3. （可选）将router暴露到全局，以便HTML中的onclick可以调用
window.router = router;
```

### 进阶思考
上面是一个最基础的实现。一个生产级别的路由库（如React-Router, Vue-Router）会复杂得多，它们还包括：

1. **动态路由**： `/user/:id` 如何匹配并提取参数。
2. **路由守卫**： 在进入/离开路由前进行权限检查或确认。
3. **懒加载**： 动态导入组件代码，优化首屏加载速度。
4. **嵌套路由**： 如何处理父路由和子路由的视图嵌套。
5. **Link组件**： 提供一个封装好的`<Link>`组件，自动处理点击事件和活动状态样式。
6. **与框架集成**： 使用React的Context、Hooks或Vue的响应式系统和插件机制来无缝集成。

希望这个从原理、API到实践的完整拆解，能帮助你彻底理解前端路由的工作机制！

